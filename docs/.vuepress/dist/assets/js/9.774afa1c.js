(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{188:function(a,t,e){"use strict";e.r(t);var s=e(0),n=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("div",{staticClass:"content"},[e("p",[a._v("在jsp中，主要有两种传递参数的方式：")]),a._v(" "),e("h1",{attrs:{id:"第一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一","aria-hidden":"true"}},[a._v("#")]),a._v(" 第一")]),a._v(" "),e("p",[a._v("通过request对象传递中文参数，也就是说传进和取出都是使用request，比如包括：\n使用")]),a._v(" "),e("div",{staticClass:"language-jsp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('< jsp:include page="Relative URL">\n\t< jsp:param name="param name" value="paramvalue" />\n< /jsp:include> \n< jsp:forward page="Relative URL">\n\t< jsp:param name="paramname" value="paramvalue" />\n< /jsp:forward> \n')])])]),e("p",[a._v("传参，使用request.getParameter()取参；\n使用request.setAttriute(name,value)传参，使用request.getAttribute(name)取参。\n出现乱码时，"),a._v('确保你已设置request.setCharacterEncoding("具体编码方式")，当然两端都得设置。')]),a._v(" "),e("h1",{attrs:{id:"第二"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二","aria-hidden":"true"}},[a._v("#")]),a._v(" 第二")]),a._v(" "),e("p",[a._v("直接在URL请求后添加，如:")]),a._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("href")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')]),a._v("zzm5460zzm.github.com?name=value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("直接传递参数"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("</")]),a._v("a")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v("\n")])])]),e("p",[a._v('这种情况下，如果系统运行于容器下，出现乱码时，解决的办法是在传参端使用两次javascript:encodeURI()或java.net.URLEncoder.encode(String value,String encoding)进行两次编码（最好是UTF-8），而在取参端使用一次javascript:decodeURI()或java.net.URLDecoder.decode(String value,String encoding)进行解码。我知道你一定会问为什么是这种不对称的关系，下面是原因：\n第一次编码，你的参数内容便不带有多字节字符了，成了纯粹的 Ascii 字符串。(这里把编第一次的结果叫成 [STR_ENC1] 好了。[STR_ENC1] 是不带有多字节字符的)\n再编一次后，提交，接收时容器(tomcat)自动解一次　（容器自动解的这一次，不管是按 GBK 还是 UTF-8 还是 ISO-8859-1 都好，都能够正确的得到 [STR_ENC1]）\n然后，再在程序中实现一次 decodeURIComponent (Java中通常使用 java.net.URLDecoder(***, "UTF-8")) 就可以得到想提交的参数的原值。')])])}],!1,null,null,null);t.default=n.exports}}]);